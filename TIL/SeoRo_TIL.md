# 250113 TIL

### ➊ 변수란?
**하나의 값을 저장하기 위해 확보한 메모리 공간 자체** 또는
**메모리 공간을 식별하기 위해 붙인 이름**을 말한다.

애플리케이션은 데이터를 입력받아 처리한다.
이때 데이터는 메모리에 저장한다.

### ➋ 메모리란?
**데이터를 저장할 수 있는 메모리 셀의 집합체**다.
메모리 셀 하나의 크기는 1Byte이며 컴퓨터는 메모리 셀의 크기 단위로 데이터를 저장하거나 읽어들인다.

각 셀은 고유의 메모리 주소를 가지며 이 메모리 주소는 메모리 공간의 위치를 나타낸다.
메모리에 저장되는 모든 데이터는 2진수로 저장된다.

#### 그러면 개발자는 어떻게 데이터에 접근해야 할까 ❓
먼저 메모리 주소를 통해 값에 직접 접근하는 방법을 생각해볼 수 있다.
그러나 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 위험이 있으며 코드가 실행되기 이전에는 값이 저장될 메모리 주소를 개발자가 알 수 없다.

따라서 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어 들여 재사용하기 위해 **변수**를 사용한다.
변수를 사용하면 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 **변수 이름으로 안전하게 값에 접근**할 수 있다.

### ➌ 식별자란?
**어떤 값을 구별해서 식별할 수 있는 고유한 이름**이다.
변수 이름을 포함하여 함수, 클래스 이름도 모두 식별자다.
식별자는 값이 저장되어 있는 **메모리 주소와 매핑 관계**를 맺으며 이 매핑 정보도 메모리에 저장되어 있다.
따라서 식별자는 **메모리 주소에 붙인 이름**이라고 할 수 있다.

### ➍ 변수 선언

변수를 사용하려면 먼저 변수 선언문을 작성해야 한다.

```
var result;
```

위의 코드는 _result_ 라는 이름으로 변수를 선언하는 문이다.
자바스크립트 엔진은 _result_ 라는 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
확보된 메모리 공간에는 **자바스크립트 엔진에 의해 _undefined_ 라는 값이 암묵적으로 할당되어 초기화**된다.

### ➎ 변수 호이스팅
자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다.
그러나 변수 선언문은 런타임이 아니라 그 이전 단계에서 먼저 실행된다.

```
console.log(result);
var result = 100;
console.log(result);
```

위의 코드를 예시로 들어보면,

자바스크립트 엔진은 _result_ 변수를 먼저 선언하여 메모리 공간을 확보하고 _undefined_ 을 할당한다.
그 다음에 선언문을 제외한 다른 코드를 순차적으로 실행한다.
따라서 위의 코드는 아래의 코드와 동일하게 동작한다.
```
var result;

console.log(result); // undefined 출력
result = 100;
console.log(result); // 100 출력
```

이처럼 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다.
사실 변수 선언뿐 아니라 함수, 클래스 등의 선언도 호이스팅된다!

### ➏ 변수 재할당
```
var result = 100;
result = 200;
```
위의 코드에서 _result_ 변수에 100을 할당하여 초기화하고
그 다음에 200을 재할당했다.

이때 이전 값 100이 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 200을 새롭게 저장하는 것이 아니라 **새로운 메모리 공간을 확보**하고 그 메모리 공간에 200을 저장한다.

그러면 기존에 100이 저장되어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않다.
이렇게 어떤 식별자와도 연결되어 있지 않은 메모리 공간의 값들을 **쓰레기 값**이라고 한다.
쓰레기 값은 **가비지 콜렉터**에 의해 메모리에서 자동 해제된다.
단, 메모리에서 언제 해제될지는 예측할 수 없다.

# 250114 TIL

### ➊ undefined
```
var result;
```
_var_ 키워드로 변수를 선언하면 자바스크립트 엔진은 값을 저장하기 위한 준비를 한다.

변수 선언문이 실행되면 아래의 두 단계를 거친다.

① 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
② 확보된 메모리에 _undefined_ 를 할당한다.

> 왜 _undefined_ 를 할당할까 ❓

만약 _undefined_ 를 할당하지 않고 ①번 과정만 수행한다고 가정해보자.
확보된 메모리 공간에는 이전에 할당되었던 쓰레기 값이 존재할 것이다.

> 왜 쓰레기 값이 존재할까 ❓

```
var result = 100;
result = 200;
```
왜 쓰레기 값이 존재하는지 설명하기 위해 예시를 들어보겠다.
위의 코드에서 _result_ 변수에 처음 100을 할당하고
그 다음에 200을 재할당한다.

이때 이전 값 100이 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 200을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 200을 저장한다.
따라서 _result_ 식별자는 200이 저장된 메모리 공간과 연결되며
이전에 100이 저장되어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않다.

![](https://velog.velcdn.com/images/okxooxoo/post/8b4496bd-d167-46b3-b7d8-2277fe171435/image.jpeg)


이처럼 메모리 상에는 더이상 사용하지 않아 어떤 식별자와도 연결되어 있지 않은 값들이 많다.
이러한 불필요한 값들을 **쓰레기 값**이라고 한다 ❗️

자바스크립트는 개발자가 변수를 초기화하지 않고 선언만 했을 때 실수로 쓰레기 값을 사용하지 않도록 _undefined_ 라는 데이터 타입으로 초기화한다.

### ➋ null
_null_ 은 변수에 값이 없다는 것을 개발자가 **의도적**으로 명시할 때 사용한다.
```
var result = 100;
result = null;
```
변수에 _null_ 을 할당하는 것은 변수가 이전에 참조하던 값인 100을 더 이상 참조하지 않겠다는 의미다.
따라서 기존의 식별자와 연결 고리를 끊어버리는 것이다.

### ➌ 그렇다면 null과 undefined의 차이는 무엇일까 ❓

_null_ 은 변수에 값이 없다는 것을 드러내기 위해 개발자가 **의도적**으로 할당하는 값이다.
그러나 _undefined_ 는 선언이 되고 초기화되지 않았기 때문에 자바스크립트 엔진이 할당하는 값이다.
따라서 변수에 _undefined_ 가 할당되어 있으면 **초기화되지 않은 변수**라는 의미가 더 강하다.

> **앞으로 사용할 것이지만 초기화되지 않은 변수**와
**의도적으로 값을 비워둔 변수**에는 큰 차이가 있다 ❗️

_null_ 과 _undefined_ 의 차이는 바로 이런 것이다.

# 250115 TIL

자바스크립트의 모든 값은 타입이 있다!
값의 타입은 변환할 수 있는데, 개발자가 의도적으로 값의 타입을 변환하는 것을
**명시적 타입 변환** 혹은 **타입 캐스팅**이라 한다.

그러나 개발자의 의도와는 상관없이 표현식을 평가하는 도중에
자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.
이를 **암묵적 타입 변환** 혹은 **타입 강제 변환**이라 한다.

기존 원시 값은 **immutable**이기 때문에
타입 변환을 하면 기존의 값이 변경되는 게 아니라
다른 타입의 새로운 원시 값을 생성하고 이를 메모리에 저장한다.

## ➊ 암묵적 타입 변환

```
㉠ '10' + 2	// '102'
㉡ 5 * '10'	// 50
㉢ !0		// true
```
위는 암묵적 타입 변환의 예시이다.
표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다.

> ㉠ 문자열과 숫자를 더하고 있으므로 문맥에 부합하지 않는다.
㉡ 숫자와 문자열을 곱하고 있으므로 문맥에 부합하지 않는다.
㉢ 숫자 0을 논리적 부정하고 있으므로 문맥에 부합하지 않는다.

이때 자바스크립트는 **에러를 발생시키지 않고 암묵적 타입 변환**한다.

> ㉠ 덧셈 기호는 문자열 연결 연산자로 동작하여 숫자 2를 문자열 '2'로 타입 변환한다.
➡️ '10' + '2' = '102'
㉡ 곱셈 기호는 피연산자로 숫자를 받기 때문에 문자열 '10'을 숫자 10으로 타입 변환한다.
➡️ 5 * 10 = 50
㉢ !의 피연산자는 boolean 타입이어야 하므로 숫자 0을 false로 타입 변환한다.
➡️ !false = true

아래처럼 암묵적 타입 변환을 할 수 없는 경우도 있으니 참고하자!
```
1 / 'one'	// NaN
```
'one'으로 숫자 1을 나눌 수 없으므로 표현식의 평가 결과는 **NaN**이다.

이처럼 **암묵적 타입 변환**을 활용하면 _parseInt(), toString()_ 같은 함수를 사용하지 않아도 타입 변환할 수 있다.
### ① 문자열 타입으로 변환
```
1 + ''		// '1'
NaN + ''	// 'NaN'
true + ''	// 'true'
```
위는 자바스크립트가 암묵적 타입 변환하는 특성을 활용하여
개발자가 **명시적**으로 문자열 타입으로 변환하는 사례다.

숫자 혹은 boolean 값에 **빈 문자열(' ')을 더함**으로써 피연산자를 문자열로 변경하는 것이다.

### ② 숫자 타입으로 변환
```
// 단항 산술 연산자를 이용하는 방법
+'0'		// 0
+'-1'		// -1
+false		// 0

// * 산술 연산자를 이용하는 방법
'0' * 1		// 0
'-1' * 1	// -1
true * 1	// 1
```
위는 자바스크립트가 암묵적 타입 변환하는 특성을 활용하여
개발자가 **명시적**으로 숫자 타입으로 변환하는 사례다.

단항 산술 연산자 혹은 * 산술 연산자의 피연산자가 숫자 타입이어야 한다는 점을 이용함으로써 피연산자를 숫자로 변경하는 것이다.

### ③ boolean 타입으로 변환
```
!!'x'		// true
!!''		// false
!!0			// false
!!NaN		// false
!!null		// false
!!undefined	// false
```
! 부정 논리 연산자를 두 번 사용하면 boolean 타입으로 변환할 수 있다.
이때, boolean으로 암묵적 타입 변환되는 값을 **Falsy** 값이라 한다.
**Falsy** 값 이외의 모든 값은 **Truthy** 값이며 true로 암묵적 타입 변환된다.

## ➋ 단축 평가
논리합( || ) 또는 논리곱( && ) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

위 말이 처음엔 와닿지 않을 수 있다. 예시를 통해 이해를 돕도록 하겠다.

### ① 논리곱 연산자 ( && )
```
'Cat' && 'Dog'	// 'Dog'
```
'Cat'과 'Dog'은 Truthy 값이기 때문에 위 표현식의 평가 결과로 true를 예상할 수 있다.
그러나 실제 평가 결과는 'Dog'이다.

왜 그럴까 🤔❓

논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.
첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다.
하지만 이 시점까지는 위 표현식을 평가할 수 없으며,
두 번째 피연산자가 위 표현식의 평가 결과를 결정한다.

이때, **논리곱 연산의 결과를 결정**하는 두 번째 피연산자인 **'Dog'를 그대로 반환**한다!

### ② 논리합 연산자 ( || )
```
'Cat' || 'Dog'	// 'Cat'
```
논리합 연산자도 동일하게 동작한다!
논리합 연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다.
이 시점에 두 번째 피연산자까지 평가하지 않아도 위 표현식이 true라는 것을 알 수 있다.

이때, **논리합 연산의 결과를 결정**하는 첫 번째 피연산자인 **'Cat'을 그대로 반환**한다.

> 이처럼 표현식을 평가하는 도중에 평가 결과가 확정된 경우
나머지 평가 과정을 생략하는 것을 **단축 평가**라고 한다.

# 250116 TIL


### ➊ 옵셔널 체이닝 연산자 (?)
옵셔널 체이닝 연산자(?)는 물음표 한 개로 표기한다.
옵셔널 체이닝 연산자는 좌항의 피연산자가 _null_ 또는 _undefined_ 인 경우
_undefined_ 를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

예시 ①
```
var student;
var result = student?.name;
console.log(result); // undefined
```
위의 코드에서 _student_ 는 선언만 되고 할당이 되지 않았다.
따라서 _undefined_ 의 값을 갖는다.
옵셔널 체이닝 연산자인 '?' 는 좌항이 _null_ 또는 _undefined_ 인 경우 _undefined_ 를 반환하기 때문에 _result_ 는 _undefined_ 이다.

예시 ②
```
var str = '';
var result = str?.length;
console.log(result); // 0
```

위의 코드에서 _str_ 변수에 빈 문자열인 ' ' 가 할당되었다.
따라서 _str_ 은 _null, undefined_ 가 아니므로 옵셔널 체이닝 연산자는 우항의 참조를 이어나간다.
_str_ 문자열의 길이인 _length_ 는 0이기 때문에 _result_ 는 0이 된다!

### ➋ null 병합 연산자 (??)
_null_ 병합 연산자(??)는 물음표 두 개로 표기한다.
_null_ 병합 연산자는 옵셔널 체이닝과 **반대** 개념이라 볼 수 있으며,
좌항의 피연산자가 _null_ 또는 _undefined_ 인 경우
우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다.

예시 ①
```
var foo = null ?? 'string';
console.log(foo); // 'string'
```

위 코드에서 ??의 좌항은 _null_ 이기 때문에 우항을 참조하게 된다.
따라서 _foo_ 를 출력하면 'string'이다.

예시 ②
```
var foo = '' ?? 'string';
console.log(foo); // ''
```

위 코드에서 ??의 좌항은 빈 문자열인 ' ' 이며 _null, undefined_ 가 아니다.
따라서 null 병합 연산자는 좌항을 참조하게 되며 ' '를 출력한다.

# 250117 TIL


![](https://velog.velcdn.com/images/okxooxoo/post/1fe24db0-1ee7-441c-8328-426e1ee5d977/image.png)

자바스크립트가 제공하는 7가지 데이터 타입은 크게 **원시 타입**과 **객체 타입**으로 구분할 수 있다.
이때 원시 타입의 값은 **변경 불가능**하며 **immutable** 이라고 한다.
객체 타입의 값은 **변경 가능**하며 **mutable** 이라고 한다.

이상하다 👀
우리는 원시 타입이든 객체 타입이든 재할당을 통해 언제든지 변수를 변경할 수 있었다.
바로 아래의 코드처럼 말이다.
```
// 원시 타입의 변수를 변경하는 경우
var result = 1;
result = 3;

// 객체 타입의 변수를 변경하는 경우
var person = {
	name: 'Kim',
    age: 25,
};
person.name = 'Lee'; // 프로퍼티 값 갱신
// 객체를 재할당
person = {
	name: 'Park',
    address: 'Seoul',
};
```

이처럼 var로 선언한 모든 변수는 변경이 가능하다.
하지만 숫자, boolean 등의 원시 타입은 immutable 이라 한다.
왜일까? 설명을 위해 자바스크립트 메모리 구조를 들여다보도록 하겠다!

### ➊ immutable
변수의 값을 변경할 수 없다는 것이 구체적으로 무엇을 의미할까?
먼저 '변수'와 '값'의 개념을 구분해서 생각해보자.

변수란 **하나의 값을 저장하기 위해 확보한 메모리 공간 자체** 또는
**그 메모리 공간을 식별하기 위해 붙인 이름**을 말한다.

값은 해당 메모리에 저장된 실질적인 데이터를 뜻한다.

변경 불가능(immutable)하다는 것은 **변수가 아니라 값에 대한 진술**이다 ❗️

변수에 다른 값을 재할당할 경우,
해당 메모리에 저장된 값이 교체되는 것이 아니라 변수가 다른 메모리와 연결된다.
아래의 그림처럼 말이다.

![](https://velog.velcdn.com/images/okxooxoo/post/017b38af-f70f-46cc-afc4-e79b66a73615/image.jpeg)

이처럼 메모리에 저장된 원시 값은 변경되지 않고 그대로 남아 있다.
변수와 연결된 메모리만 달라질 뿐이다.
따라서 원시 타입의 값은 **immutable** 하다!

원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다!

그러나 객체 타입의 값은 재할당을 하지 않아도 객체를 변경할 수 있다❗️

### ➋ mutable
객체 타입의 값은 재할당 없이 변경할 수 있다.
그렇기 때문에 **mutable** 하다고 말한다.

재할당 없이 객체를 변경하는 코드는 아래와 같다.
```
var person = {
	name: 'Lee',
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';
```

이처럼 객체가 변경될 때 메모리 구조는 아래 그림과 같다.

![](https://velog.velcdn.com/images/okxooxoo/post/ff1825c5-71e7-4229-9eff-2742af97f27c/image.jpeg)

원시 값을 갖는 변수의 값을 변경하면 재할당을 통해 메모리에 원시 값이 새롭게 생성된다.

그러나 객체는 변경해도 다른 메모리에 새롭게 객체가 생성되지 않으며
**기존의 메모리에서 값이 직접 변경**된다.

왜 객체는 변경 가능하도록 설계되었을까❓

객체를 변경할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성한다면 명확하고 신뢰성이 확보될 것이다.

그러나 객체는 크기가 매우 클 수 있고, 원시 값처럼 크기가 일정하지 않으며, 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.
즉, 메모리의 효율적 소비가 어렵고 성능이 나빠진다.

따라서 **메모리를 효율적으로 사용**하기 위해 **객체는 변경 가능한 값으로 설계**되어 있다!

### 결론 💡
원시 값이 할당된 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없기 때문에 **immutable** 하다!
객체 값이 할당된 변수는 재할당 없이 객체 값을 변경할 수 있기 때문에 **mutable** 하다!

# 250120 TIL

## webRTC

웹 브라우저가 서로 통신할 수 있도록 설계된 API

웹 브라우저 상에서 어떠한 플러그인도 필요 없이 음성 채팅과 화상 채팅, 데이터 교환까지 가능하게 하는 기술

WebRTC는 **P2P 연결**을 기반으로 하며, **미디어 서버 없이** 브라우저 간의 직접적인 통신을 지원

### P2P(Peer-to-Peer)

중앙 서버를 거치지 않고 클라이언트 컴퓨터끼리 직접 통신하는 방식

→ 서버는 단지 웹 브라우저를 특정하기 위한 **시그널링** 과정에서만 쓰임

### (참고) 미디어 서버 구축 방식

- P2P(Peer-to-Peer, Mesh)
    - 각 클라이언트가 직접 다른 클라이언트와 연결하여 데이터를 주고받는 방식
    - 소규모 회의에서 적합하지만 참여자가 많아지면 네트워크가 비효율적
- **SFU(Selective Forwarding Unit)**
    - 미디어 서버가 각 참가자의 오디오/비디오 스트림을 받고 이를 다른 참가자에게 선택적으로 전달하는 방식
    - 서버에서 **스트림을 중계**만 하고, 스트림을 **합성**하지 않음
    - 여러 참가자가 있는 회의에서 상대적으로 적은 서버 자원으로 효율적으로 동작
- **MCU(Multipoint Control Unit)**
    - 미디어 서버가 모든 스트림을 하나로 합쳐 각 참가자에게 전달하는 방식
    - 더 많은 서버 자원을 소모하지만 복잡한 회의에서 더 나은 품질 제공

→ 하나의 방에 최대 8명까지 참가할 수 있으므로 **SFU**나 **MCU** 방식이 적합해보임

### 시그널링

RTCPeerConnection들이 적절하게 데이터를 교환할 수 있도록 처리하는 과정

---

## openVidu

openVidu는 WebRTC를 기반으로 한 고수준의 **비디오 통신 플랫폼**

kurento에 기반한 웹 또는 모바일 애플리케이션에서 화상 통화를 쉽게 사용할 수 있게 하는 오픈 소스 플랫폼

kurento media server을 사용하면 브로드캐스팅을 위한 미디어 서버 구축을 스킵하고,

유저 간 연결을 위한 **시그널링 서버**만 구축하면 되기 때문에 구현이 쉬워짐

OpenVidu는 기본적으로 **SFU** 방식으로 동작하지만, 상황에 따라 **MCU** 방식도 일부 지원

이를 통해 다수의 참가자가 포함된 화상 회의에서도 효율적이고 안정적인 성능을 제공

### kurento 사용 방법 3가지

- WebRTC 브라우저에서 Kurento JavaScript SDK를 바로 사용하기 (빠르게 개발할 경우에만 추천)
- **Java EE Application Server에서 Kurento JavaScript SDK 사용 (자바 서버가 signaling 역할)**
- Node.js Application Server에서 Kurento Javascript SDK 사용 (노드 서버가 singaling 역할)

# 250121 TIL

함수란 **입력**을 받아 **출력**을 내보내는 일련의 과정이다.
자바스크립트 함수는 4가지 방법으로 정의할 수 있다.

### ➊ 함수 표현식
자바스크립트의 함수는 객체 타입의 값이다.
따라서 함수를 변수에 값처럼 할당할 수 있으며
다음과 같은 방식으로 함수를 정의할 수 있다.

```
var getSum = function add(x, y) {
	return x+y;
};

console.log(add(2, 3)); // ReferenceError
console.log(getSum(2, 3)); // 5 출력
```
위의 코드에서 _getSum_ 변수에 함수 리터럴을 할당하였다.
이와 같이 함수를 정의하는 방식을 **함수 표현식**이라 한다.

보통 우리는 함수의 이름을 사용하여 해당 함수를 호출한다.
그런데 위의 코드에서는 _add(2, 3)_으로 함수를 호출하니 _add_ 가 정의되지 않았다는 에러가 발생하였다.

왜 그럴까 ❓

우리는 먼저 **함수 이름**과 **함수 객체를 참조하는 식별자**를 구분해서 생각해야 한다.

위의 코드에서 함수 이름은 _add_ 이고,
함수 객체를 참조하는 식별자는 _getSum_ 이다.

자바스크립트에서 **함수 이름은 함수 외부에서 참조할 수 없으며 함수 몸체 내부에서만 참조할 수 있다!**

그렇기 때문에 _add(2, 3)_ 로 함수를 호출하니 _add_ 가 정의되지 않았다는 에러가 발생한 것이다!

### ➋ 함수 선언문
이번에는 **함수 선언문**의 방식을 이용하여 함수를 정의한 예제 코드를 살펴보자.

```
function add(x, y) {
	return x+y;
}

console.log(add(2, 3)); // 5 출력
```

위의 코드에서 _add_ 이름을 갖는 함수를 정의하고,
_add(2, 3)_ 으로 함수를 호출하였다.
함수 표현식과 다르게 함수 선언문은 함수 이름으로 함수를 호출했음에도 불구하고 에러가 발생하지 않았다.

왜 그럴까 ❓

**함수 선언문**으로 함수를 정의하면 자바스크립트 엔진은 함수 이름으로 식별자를 암묵 생성하고 생성된 함수 객체를 할당한다.

따라서 **함수 이름과 함수 객체를 참조하는 식별자가 동일한 이름**을 갖게 된다.

그렇기 때문에 함수 이름으로 함수를 호출해도 오류가 발생하지 않는다.
사실은 함수 이름이 아닌 **함수 객체를 참조하는 식별자로 호출**하는 것이기 때문이다 ❗️

### ➌ Function 생성자 함수
아래는 Function 생성자 함수를 이용하여 함수를 정의하는 예시다.
```
var add = new Function('x', 'y', 'return x+y');

console.log(add(2, 3)); // 5 출력
```
자바스크립트가 기본 제공하는 빌트인 함수인 _Function_ 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 _new_ 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.

그러나 _Function_ 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

### ➍ 화살표 함수

아래는 화살표 함수를 이용하여 함수를 정의하는 예시다.
```
const add = (x, y) => x + y;

console.log(add(2, 3)); // 5 출력
```

ES6에서 도입된 화살표 함수는 _function_ 키워드 대신 화살표를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있다.
화살표 함수는 **항상 익명 함수**로 정의한다 ❗️

### ➎ 함수 호이스팅

그렇다면 함수 선언문도 변수처럼 호이스팅될까 ❓

> 호이스팅이란?
선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.
변수, 함수 등의 선언문은 런타임 이전에 먼저 실행된다!

결론부터 말하자면 **함수 선언문은 호이스팅**되며,
**함수 표현식은 변수 호이스팅**이 발생하며 함수 호이스팅은 되지 않는다.

```
// 함수 표현식
var add = function (x, y) {
	return x+y;
};

// 함수 선언문
function add(x, y) {
	return x+y;
}
```

위 코드의 함수 표현식에서 함수 리터럴을 _add_ 변수에 할당하고 있다.
이때, 변수 _add_ 는 런타임 이전에 선언되며 함수 객체는 런타임에 생성되어 변수 _add_ 에 할당된다.

위 코드의 함수 선언문에서는 **런타임 이전에 함수 객체가 생성**된다.
그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.

# 250122 TIL


# ➊ 실행 컨텍스트
실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.  
실행 컨텍스트를 구성할 수 있는 방법으로는 **전역공간, 함수** 등이 있다.  
  
다음의 코드를 예시로 들며 실행 컨텍스트가 어떻게 생성되는지 살펴보겠다!  
```javascript
var a = 1;
function outer() {
    function inner() {
        console.log(a);
        var a = 3;
    }
    inner();
    console.log(a);
}
outer();
console.log(a);
```

① 먼저 위의 자바스크립트 코드를 실행하는 순간 **전역 컨텍스트**가 생성되고 콜 스택에 담긴다.  
② 그 다음에 `outer` 함수가 호출되는 순간 `outer` 실행 컨텍스트가 생성되고 콜 스택에 담긴다.  
이때, 전역 컨텍스트 위에 `outer` 실행 컨텍스트가 쌓이는데 콜 스택이 이름 그대로 **스택 구조**이기 때문이다!  
③ 그 다음에 `inner` 함수가 호출되는 순간 `inner` 실행 컨텍스트가 생성되고 콜 스택에 담긴다.  
④ `inner` 함수 실행이 종료되며 콜 스택에서 `inner` 실행 컨텍스트가 제거된다.  
⑤ `outer` 함수 실행이 종료되며 콜 스택에서 `outer` 실행 컨텍스트가 제거된다.  
마지막 줄의 `a`를 콘솔에 출력하는 문까지 실행되면 더는 실행할 코드가 남지 않는다.  
⑥ 이때 **전역 컨텍스트**가 제거되고, 콜 스택에는 아무것도 남지 않는다.  

![](https://velog.velcdn.com/images/okxooxoo/post/ceacbaf7-1cd7-4a04-9a41-2cfdbe25fd09/image.jpeg)


> 그렇다면 실행 컨텍스트에는 어떤 정보가 담길까?

`VariableEnvironment`, `LexicalEnvironment`, `ThisBinding` 이 담긴다.  
각각에 대하여 더 세부적으로 살펴보자!  

# ➋ LexicalEnvironment
`LexicalEnvironment`에는 `environmentRecord`와 `outerEnvironmentReference`로 구성되어 있다.  

## ① environmentRecord
`environmentRecord`에는 식별자 정보가 담겨 있다.  
식별자 정보는 매개변수의 이름, 함수 선언, 변수명 등이다.  
위의 예시 코드에서 식별자를 찾아보자면 `a`, `outer`, `inner`가 될 것이다.  
함수 컨텍스트가 생성될 때 함수 내의 코드 전체를 *순차적으로 살펴보면서 식별자를 수집*한다.  
  
여기서 **호이스팅**이라는 개념이 등장한다.  
> 호이스팅이란 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.  

변수, 함수 등의 식별자가 코드 실행 이전에 실행 컨텍스트의 `environmentRecord`에 등록되는 것은  
어떻게 보면 선언문이 코드의 선두로 끌어올려져 동작하는 것과 동일하기 때문이다!  
  
따라서, 아래의 코드는 다음과 같이 변환하여도 무방하다.  
```javascript
function a(x) {
    console.log(x);
    var x;
    console.log(x);
    var x = 2;
    console.log(x);
}

a(1);
```

⬇️

```javascript
function a() {
    var x;

    x = 1;
    console.log(x);
    console.log(x);
    x = 2;
    console.log(x);
}

a();
```

이처럼 변수 선언문은 호이스팅되어 코드의 선두로 끌어올려진 것처럼 동작한다!  
(변수 할당문은 원래 라인에서 실행된다.)  
정확히 말하면 변수와 같은 식별자는 코드가 실행되기 이전에 `environmentRecord`에 등록된다!  
  
변수 뿐만 아니라 함수도 `environmentRecord`에 등록되는데  
함수는 `함수 표현식`으로 선언하느냐, `함수 선언문`으로 선언하느냐에 따라 동작 방식이 달라진다.  

> 결론부터 말하자면 함수 선언문은 호이스팅되며,
함수 표현식은 변수 호이스팅이 발생하며 함수 호이스팅은 되지 않는다.

### ⓐ 함수 표현식
자바스크립트의 함수는 객체 타입의 값이다.  
따라서 함수를 변수에 값처럼 할당할 수 있으며  
다음과 같은 방식으로 함수를 정의할 수 있다.  

```javascript
var add = function (x, y) {
	return x + y;
};

console.log(add(2, 3)); // 5 출력
```
위의 코드에서 _add_ 변수에 함수 리터럴을 할당하였다.  
이와 같이 함수를 정의하는 방식을 **함수 표현식**이라 한다.  
  
### ⓑ 함수 선언문
이번에는 **함수 선언문**의 방식을 이용하여 함수를 정의한 예제 코드를 살펴보자.

```javascript
function add(x, y) {
	return x+y;
}

console.log(add(2, 3)); // 5 출력
```

위의 코드에서 _add_ 이름을 갖는 함수를 정의하고,  
_add(2, 3)_ 으로 함수를 호출하였다.  
  
**함수 선언문**으로 함수를 정의하면 자바스크립트 엔진은 함수 이름으로 *식별자를 암묵 생성*하고 생성된 함수 객체를 할당한다.  

이처럼 함수는 두 가지 방법으로 정의할 수 있다.  

그러나 함수 표현식은 함수 객체를 참조하는 식별자(변수)만이 `environmentRecord`에 등록되며 함수 자체는 호이스팅 되지 않는다!  
함수 선언문은 함수 자체가 `environmentRecord`에 등록되며 호이스팅 된다!  
(또한 함수의 이름과 동일한 식별자가 자동으로 생성되며 함수 객체가 저장된 주소를 가리킨다.)  
  
아래의 예시 코드를 통해 이해를 돕도록 하겠다.  
```javascript
console.log(sum(1, 2));
console.log(multiply(3, 4));

function sum(a, b) {
    return a + b;
}

var multiply = function (a, b) {
    return a * b;
}
```

위의 코드에서 함수가 호이스팅되면 실제로 어떻게 동작할까?  
`sum`, `multiply`가 `environmentRecord`에 등록되는데  
🚨 `multiply` 변수에는 실질적으로 값이 할당되지 않으며(undefined) `sum`에만 함수가 할당된다.  
  
따라서 아래의 코드의 동작과 동일하다.  

```javascript
var sum = function sum(a, b) {
    return a + b;
}

var multiply;

console.log(sum(1, 2)); // 3 출력
console.log(multiply(3, 4)); // 런타임 에러

multiply = function (a, b) {
    return a * b;
};
```

`multiply` 함수의 할당은 원래의 라인에서 실행되므로  
그 전에 `multiply` 함수를 호출하면 런타임 에러가 발생한다.  
  
## ② outerEnvironmentReference
`outerEnvironmentReference`은 현재 호출된 함수가 선언될 당시의 `LexicalEnvironment`을 참조한다.

위 문장으론 아직 `outerEnvironmentReference`가 무엇인지 잘 와닿지 않는다.

이를 이해하기 전에 우선 **스코프**의 개념에 대해 알아야 한다.  
  
> **스코프**란 식별자에 대한 유효 범위이다.

함수에 의해서 스코프가 생성되며 `f`라는 함수 내에서 선언한 `a`라는 변수는
오직 `f` 함수 내부에서만 접근할 수 있다!  
`f` 함수 외부에서는 `a` 변수에 접근할 수 없는데
이는 식별자에 대한 유효 범위가 존재하기 때문이다!

그러나 다음 예시 코드를 살펴보자.

```javascript
var outer = function () {
    var a = 1;
    var inner = function () {
        console.log(a);
    };
    inner(); // 1 출력
};

outer(); // 1 출력
```

`inner` 함수 내부에는 `a`라는 변수가 정의되어 있지 않으며,
`outer` 함수 내부에 `inner` 함수와 `a` 변수가 선언되어 있다.

그러나 `inner` 함수를 실행하면 `a`가 정상적으로 출력된다!

왜일까? 🤔

`inner`의 실행 컨텍스트 내부의 `environmentRecord`에는 변수 `a`가 등록되어 있지 않다.
원래대로면 `a`가 없기 때문에 에러가 발생하거나 `undefined`가 출력될 것이다.
그러나 실제로는 `outer`의 실행 컨텍스트로 거슬러 올라가 `a`를 검색하고 1을 출력한다. 

> 이처럼 **식별자의 유효 범위**를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.

  
이는 `inner`의 실행 컨텍스트에서 `outerEnvironmentReference`가
`outer`의 `LexicalEnvironment`를 참조하고 있기 때문에 가능한 일이다!  

이처럼 `outerEnvironmentReference`는 함수가 선언될 당시의 활성화된 실행 컨텍스트의 `LexicalEnvironment`에 접근한다.  

자신이 속한 부모 함수의 `LexicalEnvironment`를 참조하고 있다고 생각하면 이해가 편하다.  

위의 예시 코드를 바탕으로 실행 컨텍스트를 그림으로 표현하면 다음과 같다.

![](https://velog.velcdn.com/images/okxooxoo/post/ddec2599-98b0-4052-9eb5-1e6571323008/image.jpeg)


# ➌ VariableEnvironment
다시 처음으로 돌아가서 실행 컨텍스트에는 `VariableEnvironment`, `LexicalEnvironment`, `ThisBinding` 이 담긴다고 했다!  
`VariableEnvironment`에 담기는 내용은 `LexicalEnvironment`와 같다.  
그러나 `VariableEnvironment`은 최초 실행 시의 스냅샷을 쭉 유지하며,  
코드 진행에 따라 `LexicalEnvironment`의 내용은 달라질 수 있다.  

# ➍ ThisBinding
실행 컨텍스트의 `ThisBinding`에는 `this`로 지정된 객체가 저장된다.  
실행 컨텍스트 활성화 당시에 `this`가 지정되지 않은 경우 `this`에는 **전역 객체**가 저장된다.  

> 전역 객체에는 브라우저의 `window`, Node.js의 `global` 객체 등이 있다.
