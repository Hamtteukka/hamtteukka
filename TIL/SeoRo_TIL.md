# 250113 TIL

### ➊ 변수란?
**하나의 값을 저장하기 위해 확보한 메모리 공간 자체** 또는
**메모리 공간을 식별하기 위해 붙인 이름**을 말한다.

애플리케이션은 데이터를 입력받아 처리한다.
이때 데이터는 메모리에 저장한다.

### ➋ 메모리란?
**데이터를 저장할 수 있는 메모리 셀의 집합체**다.
메모리 셀 하나의 크기는 1Byte이며 컴퓨터는 메모리 셀의 크기 단위로 데이터를 저장하거나 읽어들인다.

각 셀은 고유의 메모리 주소를 가지며 이 메모리 주소는 메모리 공간의 위치를 나타낸다.
메모리에 저장되는 모든 데이터는 2진수로 저장된다.

#### 그러면 개발자는 어떻게 데이터에 접근해야 할까 ❓
먼저 메모리 주소를 통해 값에 직접 접근하는 방법을 생각해볼 수 있다.
그러나 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 위험이 있으며 코드가 실행되기 이전에는 값이 저장될 메모리 주소를 개발자가 알 수 없다.

따라서 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어 들여 재사용하기 위해 **변수**를 사용한다.
변수를 사용하면 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 **변수 이름으로 안전하게 값에 접근**할 수 있다.

### ➌ 식별자란?
**어떤 값을 구별해서 식별할 수 있는 고유한 이름**이다.
변수 이름을 포함하여 함수, 클래스 이름도 모두 식별자다.
식별자는 값이 저장되어 있는 **메모리 주소와 매핑 관계**를 맺으며 이 매핑 정보도 메모리에 저장되어 있다.
따라서 식별자는 **메모리 주소에 붙인 이름**이라고 할 수 있다.

### ➍ 변수 선언

변수를 사용하려면 먼저 변수 선언문을 작성해야 한다.

```
var result;
```

위의 코드는 _result_ 라는 이름으로 변수를 선언하는 문이다.
자바스크립트 엔진은 _result_ 라는 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
확보된 메모리 공간에는 **자바스크립트 엔진에 의해 _undefined_ 라는 값이 암묵적으로 할당되어 초기화**된다.

### ➎ 변수 호이스팅
자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다.
그러나 변수 선언문은 런타임이 아니라 그 이전 단계에서 먼저 실행된다.

```
console.log(result);
var result = 100;
console.log(result);
```

위의 코드를 예시로 들어보면,

자바스크립트 엔진은 _result_ 변수를 먼저 선언하여 메모리 공간을 확보하고 _undefined_ 을 할당한다.
그 다음에 선언문을 제외한 다른 코드를 순차적으로 실행한다.
따라서 위의 코드는 아래의 코드와 동일하게 동작한다.
```
var result;

console.log(result); // undefined 출력
result = 100;
console.log(result); // 100 출력
```

이처럼 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다.
사실 변수 선언뿐 아니라 함수, 클래스 등의 선언도 호이스팅된다!

### ➏ 변수 재할당
```
var result = 100;
result = 200;
```
위의 코드에서 _result_ 변수에 100을 할당하여 초기화하고
그 다음에 200을 재할당했다.

이때 이전 값 100이 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 200을 새롭게 저장하는 것이 아니라 **새로운 메모리 공간을 확보**하고 그 메모리 공간에 200을 저장한다.

그러면 기존에 100이 저장되어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않다.
이렇게 어떤 식별자와도 연결되어 있지 않은 메모리 공간의 값들을 **쓰레기 값**이라고 한다.
쓰레기 값은 **가비지 콜렉터**에 의해 메모리에서 자동 해제된다.
단, 메모리에서 언제 해제될지는 예측할 수 없다.

# 250114 TIL

### ➊ undefined
```
var result;
```
_var_ 키워드로 변수를 선언하면 자바스크립트 엔진은 값을 저장하기 위한 준비를 한다.

변수 선언문이 실행되면 아래의 두 단계를 거친다.

① 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
② 확보된 메모리에 _undefined_ 를 할당한다.

> 왜 _undefined_ 를 할당할까 ❓

만약 _undefined_ 를 할당하지 않고 ①번 과정만 수행한다고 가정해보자.
확보된 메모리 공간에는 이전에 할당되었던 쓰레기 값이 존재할 것이다.

> 왜 쓰레기 값이 존재할까 ❓

```
var result = 100;
result = 200;
```
왜 쓰레기 값이 존재하는지 설명하기 위해 예시를 들어보겠다.
위의 코드에서 _result_ 변수에 처음 100을 할당하고
그 다음에 200을 재할당한다.

이때 이전 값 100이 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 200을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 200을 저장한다.
따라서 _result_ 식별자는 200이 저장된 메모리 공간과 연결되며
이전에 100이 저장되어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않다.

![](https://velog.velcdn.com/images/okxooxoo/post/8b4496bd-d167-46b3-b7d8-2277fe171435/image.jpeg)


이처럼 메모리 상에는 더이상 사용하지 않아 어떤 식별자와도 연결되어 있지 않은 값들이 많다.
이러한 불필요한 값들을 **쓰레기 값**이라고 한다 ❗️

자바스크립트는 개발자가 변수를 초기화하지 않고 선언만 했을 때 실수로 쓰레기 값을 사용하지 않도록 _undefined_ 라는 데이터 타입으로 초기화한다.

### ➋ null
_null_ 은 변수에 값이 없다는 것을 개발자가 **의도적**으로 명시할 때 사용한다.
```
var result = 100;
result = null;
```
변수에 _null_ 을 할당하는 것은 변수가 이전에 참조하던 값인 100을 더 이상 참조하지 않겠다는 의미다.
따라서 기존의 식별자와 연결 고리를 끊어버리는 것이다.

### ➌ 그렇다면 null과 undefined의 차이는 무엇일까 ❓

_null_ 은 변수에 값이 없다는 것을 드러내기 위해 개발자가 **의도적**으로 할당하는 값이다.
그러나 _undefined_ 는 선언이 되고 초기화되지 않았기 때문에 자바스크립트 엔진이 할당하는 값이다.
따라서 변수에 _undefined_ 가 할당되어 있으면 **초기화되지 않은 변수**라는 의미가 더 강하다.

> **앞으로 사용할 것이지만 초기화되지 않은 변수**와
**의도적으로 값을 비워둔 변수**에는 큰 차이가 있다 ❗️

_null_ 과 _undefined_ 의 차이는 바로 이런 것이다.

# 250115 TIL

자바스크립트의 모든 값은 타입이 있다!
값의 타입은 변환할 수 있는데, 개발자가 의도적으로 값의 타입을 변환하는 것을
**명시적 타입 변환** 혹은 **타입 캐스팅**이라 한다.

그러나 개발자의 의도와는 상관없이 표현식을 평가하는 도중에
자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.
이를 **암묵적 타입 변환** 혹은 **타입 강제 변환**이라 한다.

기존 원시 값은 **immutable**이기 때문에
타입 변환을 하면 기존의 값이 변경되는 게 아니라
다른 타입의 새로운 원시 값을 생성하고 이를 메모리에 저장한다.

## ➊ 암묵적 타입 변환

```
㉠ '10' + 2	// '102'
㉡ 5 * '10'	// 50
㉢ !0		// true
```
위는 암묵적 타입 변환의 예시이다.
표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다.

> ㉠ 문자열과 숫자를 더하고 있으므로 문맥에 부합하지 않는다.
㉡ 숫자와 문자열을 곱하고 있으므로 문맥에 부합하지 않는다.
㉢ 숫자 0을 논리적 부정하고 있으므로 문맥에 부합하지 않는다.

이때 자바스크립트는 **에러를 발생시키지 않고 암묵적 타입 변환**한다.

> ㉠ 덧셈 기호는 문자열 연결 연산자로 동작하여 숫자 2를 문자열 '2'로 타입 변환한다.
➡️ '10' + '2' = '102'
㉡ 곱셈 기호는 피연산자로 숫자를 받기 때문에 문자열 '10'을 숫자 10으로 타입 변환한다.
➡️ 5 * 10 = 50
㉢ !의 피연산자는 boolean 타입이어야 하므로 숫자 0을 false로 타입 변환한다.
➡️ !false = true

아래처럼 암묵적 타입 변환을 할 수 없는 경우도 있으니 참고하자!
```
1 / 'one'	// NaN
```
'one'으로 숫자 1을 나눌 수 없으므로 표현식의 평가 결과는 **NaN**이다.

이처럼 **암묵적 타입 변환**을 활용하면 _parseInt(), toString()_ 같은 함수를 사용하지 않아도 타입 변환할 수 있다.
### ① 문자열 타입으로 변환
```
1 + ''		// '1'
NaN + ''	// 'NaN'
true + ''	// 'true'
```
위는 자바스크립트가 암묵적 타입 변환하는 특성을 활용하여
개발자가 **명시적**으로 문자열 타입으로 변환하는 사례다.

숫자 혹은 boolean 값에 **빈 문자열(' ')을 더함**으로써 피연산자를 문자열로 변경하는 것이다.

### ② 숫자 타입으로 변환
```
// 단항 산술 연산자를 이용하는 방법
+'0'		// 0
+'-1'		// -1
+false		// 0

// * 산술 연산자를 이용하는 방법
'0' * 1		// 0
'-1' * 1	// -1
true * 1	// 1
```
위는 자바스크립트가 암묵적 타입 변환하는 특성을 활용하여
개발자가 **명시적**으로 숫자 타입으로 변환하는 사례다.

단항 산술 연산자 혹은 * 산술 연산자의 피연산자가 숫자 타입이어야 한다는 점을 이용함으로써 피연산자를 숫자로 변경하는 것이다.

### ③ boolean 타입으로 변환
```
!!'x'		// true
!!''		// false
!!0			// false
!!NaN		// false
!!null		// false
!!undefined	// false
```
! 부정 논리 연산자를 두 번 사용하면 boolean 타입으로 변환할 수 있다.
이때, boolean으로 암묵적 타입 변환되는 값을 **Falsy** 값이라 한다.
**Falsy** 값 이외의 모든 값은 **Truthy** 값이며 true로 암묵적 타입 변환된다.

## ➋ 단축 평가
논리합( || ) 또는 논리곱( && ) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

위 말이 처음엔 와닿지 않을 수 있다. 예시를 통해 이해를 돕도록 하겠다.

### ① 논리곱 연산자 ( && )
```
'Cat' && 'Dog'	// 'Dog'
```
'Cat'과 'Dog'은 Truthy 값이기 때문에 위 표현식의 평가 결과로 true를 예상할 수 있다.
그러나 실제 평가 결과는 'Dog'이다.

왜 그럴까 🤔❓

논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.
첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다.
하지만 이 시점까지는 위 표현식을 평가할 수 없으며,
두 번째 피연산자가 위 표현식의 평가 결과를 결정한다.

이때, **논리곱 연산의 결과를 결정**하는 두 번째 피연산자인 **'Dog'를 그대로 반환**한다!

### ② 논리합 연산자 ( || )
```
'Cat' || 'Dog'	// 'Cat'
```
논리합 연산자도 동일하게 동작한다!
논리합 연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다.
이 시점에 두 번째 피연산자까지 평가하지 않아도 위 표현식이 true라는 것을 알 수 있다.

이때, **논리합 연산의 결과를 결정**하는 첫 번째 피연산자인 **'Cat'을 그대로 반환**한다.

> 이처럼 표현식을 평가하는 도중에 평가 결과가 확정된 경우
나머지 평가 과정을 생략하는 것을 **단축 평가**라고 한다.
