# 1월 13일 TIL 

## 운영 체제

> 시스템 콜이 무엇인지 설명해 주세요.

운영체제는 커널 모드와 사용자 모드로 나뉘어 구동되며, 커널 모드에서만 메모리 등의 자원을 직접 조작하고, 하드웨어를 제어할 수 있기 때문에, 커널 모드로의 전환이 필요하다. 즉, 시스템 콜은 응용프로그램이 **커널이 제공하는 서비스를 이용하기 위한 인터페이스** 이다. 

**시스템콜은 커널 영역의 기능을 사용자 모드가 가용 가능하게, 즉 프로세스가 하드웨어에 접근해서 필요한 기능을 할 수 있게 해준다.**  

- 즉, 응용프로그램은 시스템 콜을 사용해서 원하는 기능을 수행할 수 있다.
- 보통 직접적으로 시스템 콜을 사용하기 보다는 API를 통해 사용하게 된다.

> 우리가 사용하는 시스템 콜의 예시를 들어주세요.

File I/O의 open, read, write, close 등이 있다. 예를 들어, read의 경우 하드웨어 메모리에 존재하는 특정 파일에 접근해서 파일을 읽을 준비를 하는 일련의 과정이 커널 모드에서 수행되게 된다. 이외에도 python의 sys, time 등의 함수 역시 시스템 콜의 예시로 들 수 있다. 

> 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

1. **사용자 프로그램 실행** 
    1. 먼저, 사용자가 작성한 프로그램이 사용자 모드에서 실행된다. 
2. **시스템 콜 호출**
    1. 프로그램이 운영체제의 특정 기능을 사용해야 할 때, 그 기능을 호출하는데 사용되는 함수 또는 명령을 호출한다. 이것이 바로 시스템 콜이다. 
        1. 예를 들어, 파일을 열고 읽는 작업을 해야 할 때, 사용자 프로그램은 파일 관련 시스템 콜을 호출한다. 
3. **사용자 모드에서 커널 모드로 전환**
    1. 시스템 콜 호출이 발생하면, 프로그램은 현재 실행 중인 사용자 모드에서 커널 모드로 전환된다. 커널 모드에서만 운영 체제의 핵심 기능과 하드웨어 자원에 접근할 수 있기 때문이다.
4. **요청 분석 및 처리**
    1. 커널은 내부적으로 시스템 콜 각각의 서비스 루틴에 대응되는 인덱스 테이블을 지니고 있고, 시스템 콜이 호출되면 이에 대응되는 인덱스를 참조하여 서비스 루틴을 수행한다. 
        1. 예를 들어, 파일 열기 요청의 경우 해당 파일을 찾아서 열기 작업을 수행한다. 
5. **작업 수행 및 결과 반환**
    1. 운영체제는 요청된 작업을 수행하고, 결과를 메모리에 저장하거나 레지스터에 반환한다. 
        1. 예를 들어, 파일을 읽는 작업의 경우 파일 내용을 메모리에 읽어온다. 
6. **커널 모드에서 사용자 모드로 전환**
    1. 요청된 작업이 완료되면, 운영체제는 다시 사용자 모드로 전환한다.
        1. 이제 프로그램은 작업 결과를 받아 사용자 모드에서 필요한 작업을 계속할 수 있다. 
7. **프로그램 실행 재개**
    1. 프로그램은 이제 시스템 콜 이후부터 다음 작업을 계속 수행한다. 필요한 결과를 받아 사용자 모드에서 다양한 작업을 진행할 수 있다.

> 시스템 콜의 유형에 대해 설명해 주세요.

**프로세스 제어**

- 프로세스 실행, 생성, 대기 등
- **종류**
    - fork() : 새로운 프로세스 생성
    - exec() : 새로운 프로그램 실행
    - exit() : 현재 프로세스 종료
    - wait() : 자식 프로세스가 종료될 때 까지 대기

**파일 조작**

- 파일 열기, 읽기, 쓰기 등
- **종류**
    - open() : 파일 열기
    - read()
    - write()
    - close()

**장치 관리**

- 디바이스 부착, 분리, 읽기, 쓰기 등
- **종류**
    - read() : 장치 읽기
    - write() : 장치 쓰기
    - ioctl() : 장치 제어

**정보 유지**

- 시간, 날짜 설정 등
- **종류**
    - getpid() : 현재 프로세스 ID 가져오기
    - alarm()  : 지정한 시간 후에 알람 시그널을 보내는 타이머를 설정
    - sleep() : 현재 프로세스를 지정한 동안 멈춤

**통신**

- 통신 연결 생성, 제거, 상태 정보 전달 등
- **종류**
    - pipe() : 두 프로세스 간에 단방향 통신 파이프를 생성
    - shm_open() : 공유 메모리 객체를 생성하거나 열기
    - mmap() : 파일의 내용을 메모리에 매핑하여 읽거나 쓸 수 있도록 변경

**보호**

- 파일 및 디렉터리의 접근 권한과 소유자 정보를 관리 등
- **종류**
    - chmod() : 파일 또는 디렉터리의 권한 변경
    - umask() : 새로운 파일 생성 시의 기본 권한 제한 설정
    - chown() : 파일 또는 디렉터리의 소유자와 그룹 소유자 변경


> 운영체제의 Dual Mode 에 대해 설명해 주세요.

Dual Mode는 OS를 보호하고 시스템 자원에 대한 안전한 접근을 보장하기 위해, **사용자 모드와 커널 모드로 나누는 기법**이다. 

사용자 프로세스는 제한된 권한을 가지며, 하드웨어 자원에 직접 접근할 수 없다. 자원에 접근하려면 시스템 콜을 통해 커널 프로세스에 요청해야 하며, 이 과정에서 **사용자 모드에서 커널 모드로 전환**이 이루어진다. 

**커널 모드**

운영체제의 핵심인 커널 코드가 실행 되는 상태이다. 커널은 운영체제의 핵심 기능을 수행하며 하드웨어 리소스에 접근하고 관리할 수 있는 권한을 가진다. 커널 모드에서 실행되는 코드는 시스템의 모든 자원에 접근하여 제어할 수 있으므로, 시스템 콜 및 운영체제의 서비스를 제공한다. 

**사용자 모드**

사용자 모드는 일반 응용 프로그램이 실행되는 상태이다. 이 모드에서 실행되는 프로그램은 자신의 주소 공간 내에서만 작동하며, 하드웨어 리소스에 직접적인 접근이 허용되지 않는다. 즉, 사용자 모드에서는 응용 프로그램이 제한된 권한을 가지며, 시스템 리소스에 대한 직접적인 제어는 불가능하다.

> 왜 유저모드와 커널모드를 구분해야 하나요?

사용자 프로세스가 항상 시스템 자원에 직접 접근 가능한 커널 모드에서 실행된다면, 시스템에 장애를 일으킬 수 있는 위험이 따른다. 이러한 위험을 방지하기 위해, 운영체제는 상대적으로 안전한 사용자 모드에서 프로그램을 실행한다. 

> 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

통상적으로 시스템 콜은 여러 종류의 기능으로 나뉘어져 있으며, 각 시스템 콜에는 번호가 할당된다. **System call Interface는 이러한 번호에 따라 인덱스 테이블을 관리하고 서로 다른 시스템 콜을 구분**할 수 있다. 

일부 운영 체제에서는 지정된 함수의 이름이 운영체제 내부에서 시스템 콜 번호로 변환되어 호출하는 과정에서 시스템 콜을 구분하여 실행한다. 

위 두 방법 중 하나 또는 둘을 조합하여 시스템 콜을 구분하고 처리한다.

> 인터럽트가 무엇인지 설명해 주세요.

프로세스 실행 도중 예기치 않은 상황이 발생할 때, 발생한 상황을 처리한 후 실행중인 작업으로 복귀하는 것을 말한다. 

**내부 인터럽트**

- 하드웨어 고장
    - 컴퓨터 고장
    - 데이터 전달 과정에서의 비트 오류
    - 전원이 나간 경우
- 실행할 수 없는 명령어
    - 기억 장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우
- 명령어 실행 오류
    - 나누기 0을 하는 경우
- 사용 권한 위배
    - 사용자가 운영체제만 사용할 수 있는 자원에 액세스 하는 경우

**외부 인터럽트**

- 외부 인터럽트는 주로 **입출력장치**에 의해 발생된다.
    - **타이머 인터럽트**
        - 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청
    - **입출력 인터럽트**
        - 속도가 느린 입출력 장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청


> 인터럽트는 어떻게 처리하나요?

요청 → 중단 → 보관 → 인터럽트 처리 → 재개

- **인터럽트 요청**
- **프로그램 실행 중단**
    - 현재 실행 중이던 Micro Operation 까지 수행
- **현재 실행 중인 프로그램 상태 보관**
    - PCB (Process Control Block), PC (Program Counter) 저장
- **인터럽트 원인 판별**
    - 인터럽트를 요청한 장치를 식별 → 인터럽트 원인을 파악
    - Interrupt Vector 테이블을 참조하여 호출할 ISR (인터럽트 서비스 루틴) 주소 값을 얻음
- **ISR (인터럽트 서비스 루틴) 처리**
    - 실질적인 인터럽트 처리 작업을 한다.
    - 서비스 루틴 수행 중, 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1 ~ 5 과정을 수행한다.
    - 인터럽트 서비스 루틴을 실행할 때 인터럽트 플래그를 0으로 하면 인터럽트 발생을 방지할 수 있다.
- **상태 복구**
    - 상태 복구 명령어가 실행되면, 저장해 둔 PC를 다시 복원하여 이전 실행 위치로 복원한다.
- **중단된 프로그램 실행 재개**
    - PCB의 값을 이용하여 이전에 수행 중이던 프로그램을 재개한다.


> Polling 방식에 대해 설명해 주세요.

CPU가 작업을 진행하다 입출력 명령을 만나면 직접 입출력 장치에서 데이터를 가져오는 방식이다. CPU가 직접 일을 하기 때문에 입출력을 하는 동안 다른 일은 못한다. 따라서 입출력이 처리되는 동안 기다려야 하는데 시간이 오래 걸리며 작업 효율이 떨어져 현재는 사용하지 않는다. 

또한 정해진 시간이나 주기적으로 체크하는 방식으로 과거에는 작업 개수가 적었을 때 가능했던 방식이 오늘날 다양한 프로세스 처리에는 알맞지 않다. 

- **인터럽트와의 비교**
    - 어떠한 주변 장치들의 입출력이나 하드웨어 문제, 프로그램에서 예외가 발생했을 때 CPU에게 이를 알려주는 방식.

> HW / SW 인터럽트에 대해 설명해 주세요.

**HW 인터럽트**

- 하드웨어 인터럽트는 주로 하드웨어 장치에서 발생하는 이벤트로, 외부에서 발생한 신호에 의해 컴퓨터 시스템의 CPU에 전달된다.
- 이러한 인터럽트는 하드웨어 장치의 상태 변화를 나타내며, 예를 들어 데이터 전송 완료, 타이머 만료, 키보드 입력 등이 해당한다.
- 하드웨어 인터럽트는 주로 입출력 장치와의 상호 작용에 사용되며, 장치의 상태 변화를 즉시 처리할 수 있도록 한다.

**SW 인터럽트**

- 소프트웨어 인터럽트는 주로 프로그램 내에서 발생하는 이벤트로, CPU가 현재 실행 중인 명령어에 의해 생성된다.
- 예를 들어, 프로그램이 시스템 콜을 호출하거나 예외상황이 발생할 때 소프트웨어 인터럽트가 발생한다.
- 소프트웨어 인터럽트는 주로 프로세스 관리, 예외 처리, 시스템 호출 등과 관련된 작업에 사용된다.

> 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

**인터럽트 우선 순위**

- 각 인터럽트에는 우선 순위가 할당되어 있고, 더 높은 우선순위를 갖는 인터럽트가 먼저 처리 된다.
- 이는 하드웨어나 소프트웨어에서 지정된 방식으로 우선 순위가 관리된다.
- 따라서 우선 순위가 높은 인터럽트가 먼저 처리 되고, 그 후에 낮은 우선 순위의 인터럽트가 처리 된다.

**인터럽트 마스킹**

- 시스템은 한 번에 하나의 인터럽트만 처리할 수 있기 때문에, 다중 인터럽트가 발생하면 다른 인터럽트를 일시적으로 마스크하여 처리 중인 인터럽트를 완료한 후에 처리할 수 있다.
- 이를 통해 다중 인터럽트에 대한 우선 순위나 순서를 관리할 수 있다.

**인터럽트 대기 큐**

- 시스템은 인터럽트를 대기하는 큐를 유지하여 동시에 발생한 인터럽트를 처리하는 방식이다.
- 인터럽트가 발생하면 해당 인터럽트를 큐에 추가하고, 우선 순위에 따라 큐에서 처리된다.
- 이 방식은 다중 인터럽트를 효율적으로 처리할 수 있도록 한다.


## CKA
<aside>
❗**YAML 말고 명령어로 pod 만들기**

</aside>

```
kubectl run nginx --image=nginx
```

<aside>
❗**명령어로 pods가 위치되어있는 nodes 보기**

</aside>

describe 해서 봐도 된된다

```
kubectl get pods -o wide
```

하면 쭉 볼 수 있음 

<aside>
❗**컨테이너 갯수 보기**

</aside>

```
kubectl get pods
```

해서 READY에 있는 뒤에 있는 수가 컨테이너 갯수

<aside>
❗**READY 컬럼이 의미하는 것**

</aside>

Running containers in pod / total containers in pod

<aside>
❗**yaml 파일로 생성하는 쉬운 방법**

</aside>

```
kubectl run redis --image=redis123 --dry-run=client -o yaml
```

- **`-dry-run=client`**:
- 실제로 리소스를 클러스터에 적용하지 않고, 생성될 리소스의 YAML만 출력합니다.
- 리소스가 올바르게 생성될지 시뮬레이션하는 데 사용됩니다.

<aside>
❗**pod 수정하기**

</aside>

```
kubectl edit
```

```
cat redis.yml
vi redis.yml
```
