# TIL (Today I Learned)

<details>
<summary><h2>📖 2025-01-13 학습</h2></summary>

- AI를 활용한 서술형 도안 -> 기호 도안 변환 프롬프트 작성
- docker 공부 & JPA 공부
</details>

<details>
<summary><h2>📖 2025-01-14 학습</h2></summary>

### 도커의 볼륨(Volume)
- 도커 컨테이너에서 데이터를 영속적으로 저장하기 위한 방법
- 컨테이너 자체의 저장 공간을 사용하지 않고 호스트 자체의 저장 공간을 공유해서 사용하는 형태
```bash
$ docker run -v [호스트의 디렉토리 절대경로]:[컨테이너의 디렉토리 절대경로] [이미지명]:[태그명]
```
- [**호스트의 디렉토리 절대 경로**]에 디렉토리가 이미 존재할 경우 호스트의 디렉터리가 컨테이너의 디렉터리를 덮어씌움
- [**호스트의 디렉토리 절대 경로**]에 디렉토리가 존재하지 않을 경우 호스트의 디렉터리 절대 경로에 디렉터리를 새로 만들고 컨테이너의 디렉터리에 있는 파일들을 호스트의 디렉터리로 복사함함
</details>

<details>
<summary><h2>📖 2025-01-15 학습</h2></summary>

# 프로세스와 스레드

## 프로세스 (Process)

프로세스는 컴퓨터에서 실행 중인 하나의 프로그램을 의미
프로그램이 실행되면 운영체제는 디스크에 저장된 데이터를 메모리로 로드하여 실제 메모리 공간에 할당하고 CPU가 접근할 수 있는 상태가 됩니다

### 프로세스의 메모리 구조
프로세스의 메모리는 크게 4가지 구조를 가짐
- **코드(Code) 영역**  
  실행할 프로그램의 코드가 기계어로 컴파일되어 저장되는 영역으로 텍스트(text) 영역이라고도 함
  CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하며 중간에 코드가 변경되지 않도록 Read-Only 형태로 저장됨

- **데이터(Data) 영역**  
  전역 변수, 정적(static) 변수, 배열, 구조체 등이 저장되는 영역
  데이터 영역은 세부적으로 BSS(Block Started by Symbol) 영역과 데이터 영역으로 나눌 수 있다
  - BSS 영역: 초기화하지 않은 변수를 저장  
  - 데이터 영역: 초기화된 변수를 저장  
  실행 도중 변수 값이 변경될 수 있으므로 Read-Write로 저장됨

- **스택(Stack) 영역**  
  지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영
  함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸함

- **힙(Heap) 영역**  
  사용자에 의해 동적 메모리 할당이 일어나는 영역
  생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 저장하는 공간

---

## 스레드 (Thread)

스레드는 프로세스 내에서 실행되는 작은 실행 단위이며 같은 프로세스 내에서 메모리 공간을 공유하며 실행됨

### 프로세스와 스레드의 차이

- **메모리 공유**  
  프로세스는 독립된 메모리 공간을 가지고 스레드는 같은 프로세스 내에서 메모리 공간을 공유함

- **자원 할당**  
  프로세스는 운영체제로부터 자원을 할당받고 스레드는 프로세스가 할당받은 자원을 공유하여 사용

---

### 멀티 프로세스와 멀티 스레드

- **멀티 프로세스**  
  하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 방식 
  - 메모리 사용량이 많음  
  - 구현이 간단하고 안정성이 높음  

- **멀티 스레드**  
  한 프로세스 안에서 여러 개의 스레드를 동시에 실행하여 작업을 처리하는 방식
  - 자원 공유가 용이  
  - 응답성이 좋음  
  - 구현 및 디버깅이 어려울 수 있음  
  - 안정성에 문제가 발생할 가능성 있음

# MultipartFile 방식 vs Presigned URL 방식

## 1. MultipartFile 방식
- **설명**: 
  파일을 클라이언트에서 서버로 업로드한 뒤, 서버에서 S3로 업로드하는 방식

## 2. Presigned URL 방식
- **설명**: 
  클라이언트가 S3에 파일을 직접 업로드하는 방식

---

## 비교표

| 항목                  | MultipartFile 방식                                                                 | Presigned URL 방식                                                                          |
|-----------------------|-----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| **동작 방식**         | 파일을 서버에 업로드 → 서버에서 S3로 저장                                          | 클라이언트가 Presigned URL을 통해 S3에 직접 업로드                                          |
| **서버 부하**         | 서버가 파일을 처리해야 하므로 서버 부하 증가                                        | 클라이언트가 직접 S3에 업로드하므로 서버 부하 감소                                          |
| **네트워크 비용**      | 서버가 클라이언트와 S3 간 네트워크 비용 모두 부담                                   | 클라이언트가 S3와 직접 통신하므로 서버의 네트워크 비용 감소                                 |
| **보안**              | 서버에서 파일 검증 후 S3에 저장 => 보안이 비교적 우수                                 | URL이 노출되면 파일 접근 가능성 있음 (해결방법: URL 만료 시간 설정)                     |
| **구현 복잡도**       | 서버에서 파일 검증 및 업로드 로직 구현 필요                                        | Presigned URL 생성 및 클라이언트에서의 업로드 로직 구현 필요                                |
| **실시간 처리**       | 파일 검증 및 처리 후 업로드 가능                                                   | 클라이언트가 바로 업로드 가능, 업로드 속도 증가                                             |
| **사용 사례**         | 파일 검증이 중요하거나, 서버에서 추가 처리(변환, 저장) 필요                        | 대용량 파일 업로드, 서버 부하를 줄여야 하는 경우                                            |

---

## 장단점

### MultipartFile 방식
- **장점**:
  - 서버에서 파일 검증, 변환 등 추가 처리가 가능
  - 파일 저장 경로와 관련된 제어가 서버에서 간단하게 이루어짐
  - 보안상 클라이언트에서 S3에 직접 접근하지 않음
- **단점**:
  - 서버 부하와 네트워크 비용이 증가
  - 대용량 파일 업로드 시 서버에 부담이 큼
  - 서버의 리소스를 많이 소모하므로 확장성이 떨어질 수 있음

### Presigned URL 방식
- **장점**:
  - 클라이언트가 S3에 직접 업로드하므로 서버 부하 감소
  - 대용량 파일 업로드에 적합
  - 서버와 클라이언트 간 통신 최소화로 네트워크 비용 절감
- **단점**:
  - Presigned URL의 보안 관리 필요(만료 시간 설정)
  - 서버에서 파일 검증을 할 수 없으므로 클라이언트에서 검증 로직 필요
  - 구현 복잡도가 약간 증가

</details>

<details>
<summary><h2>📖 2025-01-16 학습</h2></summary>

# Pagination(페이징)
- 많은 데이터나 콘텐츠를 한 번에 로드하지 않고, 사용자가 원하는 데이터를 적절한 크기로 나눠 보여주는 방법

## Pagination 종류

### **1. Offset 기반 Pagination**
#### **개요**
- 가장 일반적인 방식으로, 데이터베이스 쿼리에서 `LIMIT`와 `OFFSET`을 사용해 페이지를 나눔
- 클라이언트는 원하는 페이지 번호와 한 페이지당 데이터 개수를 서버에 요청

#### **특징**
- **장점**:
  - 구현이 간단하고 직관적임
  - 페이지 이동과 같은 일반적인 페이징에 적합
- **단점**:
  - 데이터가 많아지면 `OFFSET` 계산 비용이 증가
  - 데이터가 추가/삭제될 경우 페이징 순서가 어긋날 수 있음

#### **SQL 예제**
```sql
SELECT * 
FROM products 
ORDER BY id 
LIMIT 10 OFFSET 20;
```
- `OFFSET 20`은 3번째 페이지(한 페이지에 10개씩) 데이터를 가져옴

---

### **2. Cursor 기반 Pagination**
#### **개요**
- 특정 데이터를 기준으로 다음 데이터를 가져오는 방식
- 일반적으로 정렬된 필드를 기준으로 `WHERE` 조건을 이용해 다음 데이터 범위를 가져옴

#### **특징**
- **장점**:
  - 데이터가 많아도 성능이 우수
  - 데이터가 추가/삭제되어도 안정적인 결과를 보장
  - 대규모 실시간 데이터 처리에 적합
- **단점**:
  - 구현이 복잡하며, 특정 필드(예: ID나 타임스탬프) 기준이 필요
  - 무작위 페이지 이동이 어려움

#### **SQL 예제**
```sql
SELECT * 
FROM products 
WHERE id > 20 
ORDER BY id 
LIMIT 10;
```
- `id > 20`을 기준으로 다음 데이터를 가져옴

---

### **3. Keyset Pagination**
#### **개요**
- Cursor 기반 Pagination의 변형으로, 특정 정렬된 필드를 사용해 다음 데이터를 가져오는 방식
- 커서를 클라이언트에 저장해 요청 시 활용

#### **특징**
- **장점**:
  - 실시간 성능이 뛰어나며 데이터 양에 무관하게 일정한 성능을 유지
  - 스크롤 페이지에 적합
- **단점**:
  - 특정 필드에 종속적
  - 이전 페이지로 이동하는 경우 추가 구현이 필요

#### **예제**
- 클라이언트에서 `last_seen_id`와 같은 커서를 전달
```sql
SELECT * 
FROM products 
WHERE created_at > '2025-01-01 00:00:00' 
ORDER BY created_at 
LIMIT 10;
```

---

### **4. Infinite Scroll**
#### **개요**
- 사용자가 스크롤을 내릴 때마다 추가 데이터를 비동기적으로 로드하는 방식
- 트위터나 인스타그램 같은 소셜 네트워크에서 많이 사용

#### **특징**
- **장점**:
  - 사용자 경험(UX) 개선
  - 한 번에 많은 데이터를 보여주지 않아 로딩 시간 단축
- **단점**:
  - 구현이 복잡
  - 특정 데이터를 빠르게 찾기 어려움
  - SEO에 불리할 수 있음

#### **구현 방법**
- 클라이언트가 마지막 데이터 ID를 서버에 전달해 추가 데이터를 요청

---

### **5. Hybrid Pagination**
#### **개요**
- Offset 기반 Pagination과 Infinite Scroll의 혼합 방식
- 페이지 이동과 무한 스크롤을 병합하여 UX와 성능을 모두 고려

#### **특징**
- **장점**:
  - UX와 SEO 균형 유지
  - 필요한 경우 정적 페이지로 전환 가능
- **단점**:
  - 구현과 설계가 복잡

---

### **비교 요약**

| **방법**            | **장점**                                | **단점**                           | **적합한 경우**                          |
|---------------------|----------------------------------------|------------------------------------|-----------------------------------------|
| Offset 기반         | 간단하고 범용적                        | 대규모 데이터에서 성능 저하           | 페이지 기반 UI, 정적 데이터             |
| Cursor 기반         | 성능 우수, 안정적                      | 구현 복잡                           | 실시간 데이터 처리, 무한 스크롤         |
| Keyset 기반         | 안정적, 스크롤 페이지에 적합            | 특정 필드 종속, 이전 페이지 이동 어려움 | 대규모 데이터, 실시간 데이터            |
| Infinite Scroll     | UX 개선                               | SEO 문제, 데이터 탐색 어려움         | SNS, 실시간 콘텐츠                     |
| Hybrid Pagination   | UX와 SEO 균형                         | 구현 복잡                           | 다양한 사용자 요구 충족, 복합적인 UI 설계 |
---
</details>


<details>
<summary><h2>📖 2025-01- 학습</h2></summary>

</details>
